# -*- coding: utf-8 -*-
"""Manga_Project_01.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DiQvqxIUq8F747laECxPotEJu7u_wlxA
"""

# Install Streamlit if not already installed
!pip install streamlit

import streamlit as st
import pandas as pd
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import linear_kernel
import ast
import math



# --- PAGE CONFIGURATION ---
st.set_page_config(page_title="Manga Recommender", page_icon="üìö", layout="wide")

# --- CUSTOM CSS FOR PROFESSIONAL UI/UX ---
st.markdown("""
    <style>
    /* Hide Streamlit Branding */
    #MainMenu {visibility: hidden;}
    footer {visibility: hidden;}
    header {visibility: hidden;}

    /* Hover effect for Manga Covers */
    .manga-card img {
        transition: transform 0.3s ease, box-shadow 0.3s ease;
    }
    .manga-card img:hover {
        transform: scale(1.05);
        box-shadow: 0 10px 20px rgba(0,0,0,0.4) !important;
    }

    /* Custom Header Design */
    .main-header {
        background: linear-gradient(90deg, #ff4b4b, #ff8c00);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        font-size: 3.5rem;
        font-weight: 900;
        margin-bottom: 0px;
        padding-bottom: 0px;
    }
    .sub-header {
        color: #808080;
        font-size: 1.2rem;
        margin-bottom: 2rem;
    }
    </style>
""", unsafe_allow_html=True)

st.markdown('<h1 class="main-header">Manga Recommender</h1>', unsafe_allow_html=True)
st.markdown('<p class="sub-header">Your intelligent manga discovery platform.</p>', unsafe_allow_html=True)

# --- COLOR DICTIONARY FOR TAGS ---
TAG_COLORS = {
    'Action': '#FF4B4B', 'Romance': '#FF69B4', 'Horror': '#8B0000',
    'Sci Fi': '#1E90FF', 'Comedy': '#FFA500', 'Drama': '#9370DB',
    'Fantasy': '#20B2AA', 'Slice of Life': '#32CD32', 'Mystery': '#483D8B',
    'Shounen': '#FF8C00', 'Shoujo': '#FF1493', 'Seinen': '#B22222',
    'Josei': '#BA55D3', 'Adventure': '#2E8B57', 'Supernatural': '#6A5ACD',
    'Psychological': '#708090', 'Sports': '#FF4500', 'Historical': '#8B4513'
}

def get_tag_html(tag):
    color = TAG_COLORS.get(tag, '#808080')
    return f"<span style='color: {color}; border: 1px solid {color}; padding: 2px 8px; border-radius: 12px; font-size: 11px; margin-right: 4px; display: inline-block; margin-bottom: 4px; font-weight: 600;'>{tag}</span>"

# --- INITIALIZE SESSION STATE ---
if 'reading_list' not in st.session_state:
    st.session_state.reading_list = {}
if 'random_manga' not in st.session_state:
    st.session_state.random_manga = pd.DataFrame()
if 'current_page' not in st.session_state:
    st.session_state.current_page = 1
if 'last_filters' not in st.session_state:
    st.session_state.last_filters = None

def toggle_list(manga_dict):
    title = manga_dict['title']
    if title in st.session_state.reading_list:
        del st.session_state.reading_list[title]
    else:
        st.session_state.reading_list[title] = manga_dict

# --- 1. LOAD DATA ---
@st.cache_data
def load_data():
    try:
        # NOTE: Change to "Manga_data.csv.gz" if you compressed your file!
        df = pd.read_csv("Manga_data.csv.gz", compression="gzip")
    except FileNotFoundError:
        st.error("Manga_data.csv not found. Please upload it to your repository.")
        return pd.DataFrame()

    df['description'] = df['description'].fillna("No description available.")
    df['rating'] = df['rating'].fillna(0)
    df['year'] = pd.to_numeric(df['year'], errors='coerce').fillna(0)

    placeholder_img = "https://via.placeholder.com/200x300.png?text=No+Cover"
    df['cover'] = df['cover'].fillna(placeholder_img)

    def get_tag_list(tag_str):
        try:
            return ast.literal_eval(tag_str)
        except:
            return []

    def process_tags(tag_str):
        tags = get_tag_list(tag_str)
        return " ".join([str(t).replace(" ", "_") for t in tags])

    df['processed_tags'] = df['tags'].apply(process_tags)
    df['tag_list'] = df['tags'].apply(get_tag_list)
    df['combined_features'] = df['processed_tags'] + " " + df['description']

    return df

df = load_data()

# --- 2. COMPUTE TF-IDF MATRIX ---
@st.cache_resource
def compute_tfidf(data):
    tfidf = TfidfVectorizer(stop_words='english', max_features=5000)
    matrix = tfidf.fit_transform(data['combined_features'])
    return matrix

if not df.empty:
    tfidf_matrix = compute_tfidf(df)

    all_tags = set()
    for tags in df['tag_list']:
        all_tags.update(tags)
    all_tags = sorted(list(all_tags))

    # --- HELPER FUNCTION: ALIGNED GRID WITH ANIMATIONS ---
    def display_manga_grid(dataframe, key_prefix):
        if dataframe.empty:
            st.warning("No manga found.")
            return

        for i in range(0, len(dataframe), 5):
            cols = st.columns(5)
            row_slice = dataframe.iloc[i:i+5]

            for col, (_, row) in zip(cols, row_slice.iterrows()):
                with col:
                    # Hover-effect manga card with fallback image
                    html_image = f'''
                    <div class="manga-card" style="display: flex; justify-content: center; margin-bottom: 10px;">
                        <img src="{row["cover"]}" referrerpolicy="no-referrer"
                        onerror="this.onerror=null;this.src='https://via.placeholder.com/200x300.png?text=No+Cover';"
                        style="width: 100%; height: 300px; object-fit: cover; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.2);">
                    </div>
                    '''
                    st.markdown(html_image, unsafe_allow_html=True)
                    st.markdown(f"**{row['title']}**")

                    # Custom Colored Tags
                    top_tags = row['tag_list'][:3]
                    if top_tags:
                        tags_html = "".join([get_tag_html(tag) for tag in top_tags])
                        st.markdown(tags_html, unsafe_allow_html=True)

                    year_val = int(row['year']) if row['year'] else 'N/A'
                    st.caption(f"‚≠ê {row['rating']} | üìÖ {year_val}")

                    # Add to List Button
                    in_list = row['title'] in st.session_state.reading_list
                    btn_text = "‚ùå Remove" if in_list else "‚ûï Add to List"
                    btn_type = "secondary" if in_list else "primary"
                    st.button(
                        btn_text,
                        key=f"{key_prefix}_{row['title']}",
                        on_click=toggle_list,
                        args=(row.to_dict(),),
                        type=btn_type,
                        use_container_width=True
                    )

                    with st.expander("üìñ Synopsis"):
                        st.write(row['description'])
            st.write("---")

    # --- SIDEBAR: SEARCH & FILTERS ---
    with st.sidebar:
        st.header("‚öôÔ∏è Search & Filters")
        st.info("These filters control the **Browse & Search** tab.")

        search_query = st.text_input("üîç Search Title:", "")

        st.markdown("### Genres")
        include_tags = st.multiselect("‚úÖ Must Include:", all_tags)
        exclude_tags = st.multiselect("üö´ Must NOT Include:", all_tags)

        st.markdown("### Ratings & Year")
        min_rating = st.slider("Min Rating", 0.0, 5.0, 4.0, 0.1)
        years = st.slider("Year Range", 1950, 2024, (2000, 2024))

        sort_by = st.selectbox("Sort By:", ["Highest Rated", "Newest", "Oldest", "A-Z"])

    # --- UI LAYOUT TABS ---
    tab1, tab2, tab3, tab4 = st.tabs([
        "üéØ AI Recommendations",
        "üîç Browse & Search",
        "üé≤ Surprise Me!",
        f"üìö My Reading List ({len(st.session_state.reading_list)})"])

    # --- TAB 1: RECOMMENDATIONS ---
    with tab1:
        st.subheader("Find Similar Manga using AI Content-Matching")
        col1, col2 = st.columns([3, 1])

        with col1:
            manga_titles = df['title'].dropna().unique().tolist()
            selected_manga = st.selectbox("Select a Manga you like:", [""] + manga_titles)
        with col2:
            num_recs = st.slider("Number of Recommendations:", 1, 30, 10)

        if selected_manga:
            idx = df.index[df['title'] == selected_manga].tolist()[0]
            cosine_sim = linear_kernel(tfidf_matrix[idx], tfidf_matrix).flatten()
            sim_indices = cosine_sim.argsort()[:-num_recs-2:-1][1:]
            recs = df.iloc[sim_indices]

            st.write(f"### Because you liked **{selected_manga}**:")
            display_manga_grid(recs, key_prefix="rec")

            # Export Recommendations to CSV
            export_recs = recs[['title', 'rating', 'year', 'tags', 'description', 'cover']].copy()
            export_recs['Cover Preview'] = export_recs['cover'].apply(lambda x: f'=IMAGE("{x}")')
            export_recs = export_recs[['title', 'Cover Preview', 'rating', 'year', 'tags', 'description', 'cover']]
            csv_data_recs = export_recs.to_csv(index=False).encode('utf-8')

            st.download_button(
                label=f"üì• Download these Recommendations as CSV",
                data=csv_data_recs,
                file_name=f"Recommendations_for_{selected_manga.replace(' ', '_')}.csv",
                mime="text/csv",
                use_container_width=True
            )

    # --- TAB 2: BROWSE & SEARCH (PAGINATED) ---
    with tab2:
        st.subheader("Explore the Catalog")

        # 1. Capture current filter state from sidebar
        current_filters = (search_query, tuple(include_tags), tuple(exclude_tags), min_rating, tuple(years), sort_by)

        # 2. Reset to Page 1 if filters were changed
        if st.session_state.last_filters != current_filters:
            st.session_state.current_page = 1
            st.session_state.last_filters = current_filters

        # 3. Apply Filters
        filtered = df[
            (df['rating'] >= min_rating) &
            (df['year'] >= years[0]) &
            (df['year'] <= years[1])
        ]

        if search_query:
            filtered = filtered[filtered['title'].str.contains(search_query, case=False, na=False)]

        if include_tags:
            filtered = filtered[filtered['tag_list'].apply(lambda x: all(t in x for t in include_tags))]
        if exclude_tags:
            filtered = filtered[filtered['tag_list'].apply(lambda x: not any(t in x for t in exclude_tags))]

        if sort_by == "Highest Rated":
            filtered = filtered.sort_values(by='rating', ascending=False)
        elif sort_by == "Newest":
            filtered = filtered.sort_values(by='year', ascending=False)
        elif sort_by == "Oldest":
            filtered = filtered.sort_values(by='year', ascending=True)
        elif sort_by == "A-Z":
            filtered = filtered.sort_values(by='title', ascending=True)

        # 4. PAGINATION LOGIC
        ITEMS_PER_PAGE = 30
        total_results = len(filtered)
        total_pages = math.ceil(total_results / ITEMS_PER_PAGE) if total_results > 0 else 1

        if st.session_state.current_page > total_pages:
            st.session_state.current_page = total_pages

        start_idx = (st.session_state.current_page - 1) * ITEMS_PER_PAGE
        end_idx = start_idx + ITEMS_PER_PAGE
        paginated_res = filtered.iloc[start_idx:end_idx]

        st.success(f"Found {total_results} matching manga! Showing page {st.session_state.current_page} of {total_pages}.")

        # Display the paginated results
        display_manga_grid(paginated_res, key_prefix="filter")

        # 5. PAGINATION BUTTONS
        if total_pages > 1:
            st.write("---")
            p_col1, p_col2, p_col3 = st.columns([1, 2, 1])
            with p_col1:
                if st.button("‚¨ÖÔ∏è Previous Page", disabled=(st.session_state.current_page == 1), use_container_width=True):
                    st.session_state.current_page -= 1
                    st.rerun()
            with p_col2:
                st.markdown(f"<div style='text-align: center; font-size: 16px; font-weight: bold; padding-top: 5px;'>Page {st.session_state.current_page} of {total_pages}</div>", unsafe_allow_html=True)
            with p_col3:
                if st.button("Next Page ‚û°Ô∏è", disabled=(st.session_state.current_page == total_pages), use_container_width=True):
                    st.session_state.current_page += 1
                    st.rerun()

    # --- TAB 3: SURPRISE ME ---
    with tab3:
        st.subheader("Don't know what to read? Let us pick for you!")
        if st.button("üé≤ Roll 10 Random Highly-Rated Manga!", use_container_width=True):
            st.session_state.random_manga = df[df['rating'] >= 4.0].sample(10)
        if not st.session_state.random_manga.empty:
            st.write("### Your Random Picks:")
            display_manga_grid(st.session_state.random_manga, key_prefix="rand")

    # --- TAB 4: READING LIST ---
    with tab4:
        st.subheader("Your Saved Manga")
        if not st.session_state.reading_list:
            st.info("Your reading list is empty. Browse the catalog or get recommendations to add some!")
        else:
            list_df = pd.DataFrame(list(st.session_state.reading_list.values()))

            # Export setup for spreadsheet image formulas
            export_df = list_df[['title', 'rating', 'year', 'tags', 'description', 'cover']].copy()
            export_df['Cover Preview'] = export_df['cover'].apply(lambda x: f'=IMAGE("{x}")')
            export_df = export_df[['title', 'Cover Preview', 'rating', 'year', 'tags', 'description', 'cover']]
            csv_data = export_df.to_csv(index=False).encode('utf-8')

            col_a, col_b = st.columns([1, 1])
            with col_a:
                st.download_button("üì• Download List as CSV", data=csv_data, file_name="My_Manga_Reading_List.csv", mime="text/csv", use_container_width=True)
            with col_b:
                if st.button("üóëÔ∏è Clear Reading List", use_container_width=True):
                    st.session_state.reading_list = {}
                    st.rerun()

            st.write("---")
            display_manga_grid(list_df, key_prefix="list")

