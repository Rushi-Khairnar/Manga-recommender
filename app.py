# -*- coding: utf-8 -*-
"""Manga_Project_02.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DiQvqxIUq8F747laECxPotEJu7u_wlxA
"""

import streamlit as st
import pandas as pd
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import linear_kernel
import ast

# Page Configuration
st.set_page_config(page_title="Manga Recommender", page_icon="ðŸ“š", layout="wide")

st.title("ðŸ“š Manga Recommender & Filter App")
st.markdown("Discover new manga based on your favorites or filter by your specific tastes!")

# 1. Load Data and Cache it
@st.cache_data
def load_data():
    try:
        # NOTE: If you used the gzip method, change this to "Manga_data.csv.gz"
        df = pd.read_csv("Manga_data.csv.gz", compression="gzip")
    except FileNotFoundError:
        st.error("Manga_data.csv not found. Please upload it.")
        return pd.DataFrame()

    df['description'] = df['description'].fillna("No description available.")
    df['rating'] = df['rating'].fillna(0)
    df['year'] = pd.to_numeric(df['year'], errors='coerce').fillna(0)

    def get_tag_list(tag_str):
        try:
            return ast.literal_eval(tag_str)
        except:
            return []

    def process_tags(tag_str):
        tags = get_tag_list(tag_str)
        return " ".join([str(t).replace(" ", "_") for t in tags])

    df['processed_tags'] = df['tags'].apply(process_tags)
    df['tag_list'] = df['tags'].apply(get_tag_list)
    df['combined_features'] = df['processed_tags'] + " " + df['description']

    return df

df = load_data()

# 2. Compute TF-IDF Matrix (Cached for speed)
@st.cache_resource
def compute_tfidf(data):
    tfidf = TfidfVectorizer(stop_words='english', max_features=5000)
    matrix = tfidf.fit_transform(data['combined_features'])
    return matrix

if not df.empty:
    tfidf_matrix = compute_tfidf(df)

    # Extract unique tags for the sidebar
    all_tags = set()
    for tags in df['tag_list']:
        all_tags.update(tags)
    all_tags = sorted(list(all_tags))

    # --- HELPER FUNCTION: BEAUTIFUL ALIGNED GRID ---
    def display_manga_grid(dataframe):
        # Break the results into chunks of 5 to create perfect rows
        for i in range(0, len(dataframe), 5):
            cols = st.columns(5)
            row_slice = dataframe.iloc[i:i+5]

            for col, (_, row) in zip(cols, row_slice.iterrows()):
                with col:
                    # By forcing height: 300px and object-fit: cover, all images become uniform!
                    html_image = f'''
                    <div style="display: flex; justify-content: center; margin-bottom: 10px;">
                        <img src="{row["cover"]}" referrerpolicy="no-referrer"
                        style="width: 100%; height: 300px; object-fit: cover; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.2);">
                    </div>
                    '''
                    st.markdown(html_image, unsafe_allow_html=True)
                    st.markdown(f"**{row['title']}**")

                    year_val = int(row['year']) if row['year'] else 'N/A'
                    st.caption(f"â­ {row['rating']} | ðŸ“… {year_val}")

                    with st.expander("ðŸ“– Synopsis"):
                        st.write(row['description'])

            # Add a subtle visual divider between rows
            st.write("---")

    # --- UI LAYOUT ---
    tab1, tab2 = st.tabs(["ðŸŽ¯ Content-Based Recommendations", "ðŸ” Filter Manga"])

    # TAB 1: RECOMMENDATIONS
    with tab1:
        st.subheader("Find Similar Manga")
        col1, col2 = st.columns([3, 1])

        with col1:
            manga_titles = df['title'].dropna().unique().tolist()
            selected_manga = st.selectbox("Select a Manga you like:", [""] + manga_titles)
        with col2:
            # INCREASED TO 30
            num_recs = st.slider("Number of Recommendations:", 1, 30, 10)

        if selected_manga:
            idx = df.index[df['title'] == selected_manga].tolist()[0]
            cosine_sim = linear_kernel(tfidf_matrix[idx], tfidf_matrix).flatten()
            sim_indices = cosine_sim.argsort()[:-num_recs-2:-1][1:]

            recs = df.iloc[sim_indices]

            st.write(f"### Because you liked **{selected_manga}**:")
            display_manga_grid(recs)

    # TAB 2: FILTERING
    with tab2:
        st.subheader("Filter Manga by Criteria")

        f_col1, f_col2, f_col3 = st.columns(3)
        with f_col1:
            min_rating = st.slider("Minimum Rating", 0.0, 5.0, 4.0, 0.1)
        with f_col2:
            years = st.slider("Release Year Range", 1950, 2024, (2000, 2024))
        with f_col3:
            selected_tags = st.multiselect("Must include tags:", all_tags)

        if st.button("Apply Filters", use_container_width=True):
            filtered = df[
                (df['rating'] >= min_rating) &
                (df['year'] >= years[0]) &
                (df['year'] <= years[1])
            ]

            if selected_tags:
                filtered = filtered[filtered['tag_list'].apply(lambda x: all(t in x for t in selected_tags))]

            if filtered.empty:
                st.warning("No manga matched your criteria.")
            else:
                st.success(f"Found {len(filtered)} matching manga! Showing top 30:")
                # INCREASED TO 30
                res = filtered.sort_values(by='rating', ascending=False).head(30)

                display_manga_grid(res)

