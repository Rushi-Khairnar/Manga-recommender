# -*- coding: utf-8 -*-
"""Manga_Project_02.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DiQvqxIUq8F747laECxPotEJu7u_wlxA
"""

import streamlit as st
import pandas as pd
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import linear_kernel
import ast
import math

# --- PAGE CONFIGURATION ---
st.set_page_config(page_title="Manga Recommender", page_icon="üìö", layout="wide")

st.title("üìö Ultimate Manga Recommender")
st.markdown("Discover new manga, filter by your specific tastes, and build your reading list!")

# --- COLOR DICTIONARY FOR TAGS ---
TAG_COLORS = {
    'Action': '#FF4B4B', 'Romance': '#FF69B4', 'Horror': '#8B0000',
    'Sci Fi': '#1E90FF', 'Comedy': '#FFA500', 'Drama': '#9370DB',
    'Fantasy': '#20B2AA', 'Slice of Life': '#32CD32', 'Mystery': '#483D8B',
    'Shounen': '#FF8C00', 'Shoujo': '#FF1493', 'Seinen': '#B22222',
    'Josei': '#BA55D3', 'Adventure': '#2E8B57', 'Supernatural': '#6A5ACD',
    'Psychological': '#708090', 'Sports': '#FF4500', 'Historical': '#8B4513'
}

def get_tag_html(tag):
    color = TAG_COLORS.get(tag, '#808080')
    return f"<span style='color: {color}; border: 1px solid {color}; padding: 2px 8px; border-radius: 12px; font-size: 11px; margin-right: 4px; display: inline-block; margin-bottom: 4px; font-weight: 600;'>{tag}</span>"

# --- INITIALIZE SESSION STATE ---
if 'reading_list' not in st.session_state:
    st.session_state.reading_list = {}
if 'random_manga' not in st.session_state:
    st.session_state.random_manga = pd.DataFrame()
if 'current_page' not in st.session_state:
    st.session_state.current_page = 1
if 'last_filters' not in st.session_state:
    st.session_state.last_filters = None

def toggle_list(manga_dict):
    title = manga_dict['title']
    if title in st.session_state.reading_list:
        del st.session_state.reading_list[title]
    else:
        st.session_state.reading_list[title] = manga_dict

# --- 1. LOAD DATA ---
@st.cache_data
def load_data():
    try:
        df = pd.read_csv("Manga_data.csv.gz", compression="gzip")
    except FileNotFoundError:
        st.error("Manga_data.csv not found. Please upload it.")
        return pd.DataFrame()

    df['description'] = df['description'].fillna("No description available.")
    df['rating'] = df['rating'].fillna(0)
    df['year'] = pd.to_numeric(df['year'], errors='coerce').fillna(0)

    placeholder_img = "https://via.placeholder.com/200x300.png?text=No+Cover"
    df['cover'] = df['cover'].fillna(placeholder_img)

    def get_tag_list(tag_str):
        try:
            return ast.literal_eval(tag_str)
        except:
            return []

    def process_tags(tag_str):
        tags = get_tag_list(tag_str)
        return " ".join([str(t).replace(" ", "_") for t in tags])

    df['processed_tags'] = df['tags'].apply(process_tags)
    df['tag_list'] = df['tags'].apply(get_tag_list)
    df['combined_features'] = df['processed_tags'] + " " + df['description']

    return df

df = load_data()

# --- 2. COMPUTE TF-IDF MATRIX ---
@st.cache_resource
def compute_tfidf(data):
    tfidf = TfidfVectorizer(stop_words='english', max_features=5000)
    matrix = tfidf.fit_transform(data['combined_features'])
    return matrix

if not df.empty:
    tfidf_matrix = compute_tfidf(df)

    all_tags = set()
    for tags in df['tag_list']:
        all_tags.update(tags)
    all_tags = sorted(list(all_tags))

    # --- HELPER FUNCTION: ALIGNED GRID ---
    def display_manga_grid(dataframe, key_prefix):
        if dataframe.empty:
            st.warning("No manga found.")
            return

        for i in range(0, len(dataframe), 5):
            cols = st.columns(5)
            row_slice = dataframe.iloc[i:i+5]

            for col, (_, row) in zip(cols, row_slice.iterrows()):
                with col:
                    html_image = f'''
                    <div style="display: flex; justify-content: center; margin-bottom: 10px;">
                        <img src="{row["cover"]}" referrerpolicy="no-referrer"
                        onerror="this.onerror=null;this.src='https://via.placeholder.com/200x300.png?text=No+Cover';"
                        style="width: 100%; height: 300px; object-fit: cover; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.2);">
                    </div>
                    '''
                    st.markdown(html_image, unsafe_allow_html=True)
                    st.markdown(f"**{row['title']}**")

                    top_tags = row['tag_list'][:3]
                    if top_tags:
                        tags_html = "".join([get_tag_html(tag) for tag in top_tags])
                        st.markdown(tags_html, unsafe_allow_html=True)

                    year_val = int(row['year']) if row['year'] else 'N/A'
                    st.caption(f"‚≠ê {row['rating']} | üìÖ {year_val}")

                    in_list = row['title'] in st.session_state.reading_list
                    btn_text = "‚ùå Remove" if in_list else "‚ûï Add to List"
                    btn_type = "secondary" if in_list else "primary"
                    st.button(
                        btn_text,
                        key=f"{key_prefix}_{row['title']}",
                        on_click=toggle_list,
                        args=(row.to_dict(),),
                        type=btn_type,
                        use_container_width=True
                    )

                    with st.expander("üìñ Synopsis"):
                        st.write(row['description'])
            st.write("---")

    # --- UI LAYOUT TABS ---
    tab1, tab2, tab3, tab4 = st.tabs([
        "üéØ Recommendations",
        "üîç Filter & Search",
        "üé≤ Surprise Me!",
        f"üìö My Reading List ({len(st.session_state.reading_list)})"
    ])

    # --- TAB 1: RECOMMENDATIONS ---
    with tab1:
        st.subheader("Find Similar Manga")
        col1, col2 = st.columns([3, 1])

        with col1:
            manga_titles = df['title'].dropna().unique().tolist()
            selected_manga = st.selectbox("Select a Manga you like:", [""] + manga_titles)
        with col2:
            num_recs = st.slider("Number of Recommendations:", 1, 30, 10)

        if selected_manga:
            idx = df.index[df['title'] == selected_manga].tolist()[0]
            cosine_sim = linear_kernel(tfidf_matrix[idx], tfidf_matrix).flatten()
            sim_indices = cosine_sim.argsort()[:-num_recs-2:-1][1:]
            recs = df.iloc[sim_indices]

            st.write(f"### Because you liked **{selected_manga}**:")
            display_manga_grid(recs, key_prefix="rec")

    # --- TAB 2: FILTERING & SEARCH (NOW PAGINATED) ---
    with tab2:
        st.subheader("Search & Filter Manga by Criteria")

        search_query = st.text_input("üîç Search by Title (e.g., 'Naruto', 'Titan', 'Leveling'):", "")

        f_col1, f_col2 = st.columns(2)
        with f_col1:
            include_tags = st.multiselect("‚úÖ Must INCLUDE genres:", all_tags)
        with f_col2:
            exclude_tags = st.multiselect("üö´ Must NOT INCLUDE genres:", all_tags)

        f_col3, f_col4, f_col5 = st.columns(3)
        with f_col3:
            min_rating = st.slider("Minimum Rating", 0.0, 5.0, 4.0, 0.1)
        with f_col4:
            years = st.slider("Release Year Range", 1950, 2024, (2000, 2024))
        with f_col5:
            sort_by = st.selectbox("Sort Results By:", ["Highest Rated", "Newest", "Oldest", "A-Z"])

        # 1. Capture current filter state
        current_filters = (search_query, tuple(include_tags), tuple(exclude_tags), min_rating, tuple(years), sort_by)

        # 2. Reset to Page 1 if filters were changed
        if st.session_state.last_filters != current_filters:
            st.session_state.current_page = 1
            st.session_state.last_filters = current_filters

        # 3. Apply Filters
        filtered = df[
            (df['rating'] >= min_rating) &
            (df['year'] >= years[0]) &
            (df['year'] <= years[1])
        ]

        if search_query:
            filtered = filtered[filtered['title'].str.contains(search_query, case=False, na=False)]

        if include_tags:
            filtered = filtered[filtered['tag_list'].apply(lambda x: all(t in x for t in include_tags))]
        if exclude_tags:
            filtered = filtered[filtered['tag_list'].apply(lambda x: not any(t in x for t in exclude_tags))]

        if sort_by == "Highest Rated":
            filtered = filtered.sort_values(by='rating', ascending=False)
        elif sort_by == "Newest":
            filtered = filtered.sort_values(by='year', ascending=False)
        elif sort_by == "Oldest":
            filtered = filtered.sort_values(by='year', ascending=True)
        elif sort_by == "A-Z":
            filtered = filtered.sort_values(by='title', ascending=True)

        # 4. PAGINATION LOGIC
        ITEMS_PER_PAGE = 30
        total_results = len(filtered)
        total_pages = math.ceil(total_results / ITEMS_PER_PAGE) if total_results > 0 else 1

        # Fallback if page gets out of bounds somehow
        if st.session_state.current_page > total_pages:
            st.session_state.current_page = total_pages

        start_idx = (st.session_state.current_page - 1) * ITEMS_PER_PAGE
        end_idx = start_idx + ITEMS_PER_PAGE
        paginated_res = filtered.iloc[start_idx:end_idx]

        st.success(f"Found {total_results} matching manga! Showing page {st.session_state.current_page} of {total_pages}.")

        # Display the paginated results
        display_manga_grid(paginated_res, key_prefix="filter")

        # 5. PAGINATION BUTTONS
        if total_pages > 1:
            st.write("---")
            p_col1, p_col2, p_col3 = st.columns([1, 2, 1])
            with p_col1:
                if st.button("‚¨ÖÔ∏è Previous Page", disabled=(st.session_state.current_page == 1), use_container_width=True):
                    st.session_state.current_page -= 1
                    st.rerun()
            with p_col2:
                st.markdown(f"<div style='text-align: center; font-size: 16px; font-weight: bold; padding-top: 5px;'>Page {st.session_state.current_page} of {total_pages}</div>", unsafe_allow_html=True)
            with p_col3:
                if st.button("Next Page ‚û°Ô∏è", disabled=(st.session_state.current_page == total_pages), use_container_width=True):
                    st.session_state.current_page += 1
                    st.rerun()

    # --- TAB 3: SURPRISE ME ---
    with tab3:
        st.subheader("Don't know what to read? Let us pick for you!")
        if st.button("üé≤ Roll 10 Random Highly-Rated Manga!", use_container_width=True):
            st.session_state.random_manga = df[df['rating'] >= 4.0].sample(10)
        if not st.session_state.random_manga.empty:
            st.write("### Your Random Picks:")
            display_manga_grid(st.session_state.random_manga, key_prefix="rand")

    # --- TAB 4: READING LIST ---
    with tab4:
        st.subheader("Your Saved Manga")
        if not st.session_state.reading_list:
            st.info("Your reading list is empty. Go add some manga from the other tabs!")
        else:
            list_df = pd.DataFrame(list(st.session_state.reading_list.values()))
            export_df = list_df[['title', 'rating', 'year', 'tags', 'description']].copy()
            csv_data = export_df.to_csv(index=False).encode('utf-8')

            col_a, col_b = st.columns([1, 1])
            with col_a:
                st.download_button("üì• Download List as CSV", data=csv_data, file_name="My_Manga_Reading_List.csv", mime="text/csv", use_container_width=True)
            with col_b:
                if st.button("üóëÔ∏è Clear Reading List", use_container_width=True):
                    st.session_state.reading_list = {}
                    st.rerun()

            st.write("---")
            display_manga_grid(list_df, key_prefix="list")

