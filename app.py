# -*- coding: utf-8 -*-
"""Manga_Project_01.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DiQvqxIUq8F747laECxPotEJu7u_wlxA
"""

import streamlit as st
import pandas as pd
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import linear_kernel
import ast
import math

# --- PAGE CONFIGURATION ---
st.set_page_config(page_title="Manga Recommender", page_icon="üìö", layout="wide", initial_sidebar_state="expanded")

# --- PREMIUM NEXT-GEN CSS ---
st.markdown("""
    <style>
    /* Import Premium Font */
    @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;800&display=swap');

    html, body, [class*="css"] {
        font-family: 'Poppins', sans-serif;
    }

    /* Hide Streamlit Branding */
    #MainMenu {visibility: hidden;}
    footer {visibility: hidden;}
    header {visibility: hidden;}

    /* Netflix-Style Hero Header */
    .hero-container {
        padding: 2rem 0 3rem 0;
        text-align: center;
        background: radial-gradient(circle at center, rgba(255, 75, 75, 0.1) 0%, transparent 70%);
    }
    .main-header {
        background: linear-gradient(135deg, #ff4b4b, #ff8c00);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        font-size: 4rem;
        font-weight: 800;
        margin-bottom: 0px;
        padding-bottom: 0px;
        text-transform: uppercase;
        letter-spacing: 2px;
    }
    .sub-header {
        color: #a0aec0;
        font-size: 1.2rem;
        font-weight: 300;
        margin-top: 10px;
    }

    /* Modern Manga Poster Cards */
    .manga-poster {
        position: relative;
        border-radius: 12px;
        overflow: hidden;
        box-shadow: 0 10px 20px rgba(0,0,0,0.3);
        transition: transform 0.3s ease, box-shadow 0.3s ease;
        background-color: #1a202c;
        margin-bottom: 15px;
        cursor: pointer;
    }
    .manga-poster:hover {
        transform: translateY(-8px) scale(1.02);
        box-shadow: 0 15px 30px rgba(255, 75, 75, 0.3);
    }
    .manga-img {
        width: 100%;
        height: 340px;
        object-fit: cover;
        display: block;
    }

    /* Dark Gradient Overlay for Text */
    .manga-overlay {
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        background: linear-gradient(to top, rgba(15, 23, 42, 1) 0%, rgba(15, 23, 42, 0.8) 60%, transparent 100%);
        padding: 20px 12px 10px 12px;
        display: flex;
        flex-direction: column;
        justify-content: flex-end;
    }
    .manga-title {
        color: #ffffff;
        font-size: 15px;
        font-weight: 600;
        margin: 0;
        line-height: 1.2;
        display: -webkit-box;
        -webkit-line-clamp: 2;
        -webkit-box-orient: vertical;
        overflow: hidden;
    }
    .manga-stats {
        color: #fbbf24;
        font-size: 12px;
        font-weight: 600;
        margin-top: 5px;
    }

    /* Customizing Streamlit Tabs */
    .stTabs [data-baseweb="tab-list"] {
        gap: 24px;
        justify-content: center;
    }
    .stTabs [data-baseweb="tab"] {
        height: 50px;
        white-space: pre-wrap;
        border-radius: 8px 8px 0 0;
        padding-top: 10px;
        padding-bottom: 10px;
        font-size: 16px;
        font-weight: 600;
    }
    </style>
""", unsafe_allow_html=True)

# --- HEADER SECTION ---
st.markdown('''
    <div class="hero-container">
        <h1 class="main-header">MangaVault</h1>
        <p class="sub-header">Discover, track, and curate your ultimate manga collection.</p>
    </div>
''', unsafe_allow_html=True)

# --- COLOR DICTIONARY FOR TAGS ---
TAG_COLORS = {
    'Action': '#ef4444', 'Romance': '#ec4899', 'Horror': '#991b1b',
    'Sci Fi': '#3b82f6', 'Comedy': '#f59e0b', 'Drama': '#8b5cf6',
    'Fantasy': '#10b981', 'Slice of Life': '#84cc16', 'Mystery': '#6366f1',
    'Shounen': '#f97316', 'Shoujo': '#f43f5e', 'Seinen': '#b91c1c',
    'Josei': '#d946ef', 'Adventure': '#0ea5e9', 'Supernatural': '#8b5cf6',
    'Psychological': '#64748b', 'Sports': '#ea580c', 'Historical': '#b45309'
}

def get_tag_html(tag):
    color = TAG_COLORS.get(tag, '#475569')
    return f"<span style='background-color: {color}20; color: {color}; border: 1px solid {color}50; padding: 2px 8px; border-radius: 4px; font-size: 10px; margin-right: 4px; display: inline-block; margin-bottom: 4px; font-weight: 600; letter-spacing: 0.5px;'>{tag.upper()}</span>"

# --- INITIALIZE SESSION STATE ---
if 'reading_list' not in st.session_state:
    st.session_state.reading_list = {}
if 'random_manga' not in st.session_state:
    st.session_state.random_manga = pd.DataFrame()
if 'current_page' not in st.session_state:
    st.session_state.current_page = 1
if 'last_filters' not in st.session_state:
    st.session_state.last_filters = None

def toggle_list(manga_dict):
    title = manga_dict['title']
    if title in st.session_state.reading_list:
        del st.session_state.reading_list[title]
    else:
        st.session_state.reading_list[title] = manga_dict

# --- 1. LOAD DATA ---
@st.cache_data
def load_data():
    try:
        df = pd.read_csv("Manga_data.csv.gz", compression="gzip") # Change to .csv.gz if compressed
    except FileNotFoundError:
        st.error("Manga_data.csv not found. Please upload it.")
        return pd.DataFrame()

    df['description'] = df['description'].fillna("No synopsis available for this title.")
    df['rating'] = df['rating'].fillna(0)
    df['year'] = pd.to_numeric(df['year'], errors='coerce').fillna(0)

    placeholder_img = "https://via.placeholder.com/300x450.png?text=Cover+Not+Found"
    df['cover'] = df['cover'].fillna(placeholder_img)

    def get_tag_list(tag_str):
        try:
            return ast.literal_eval(tag_str)
        except:
            return []

    def process_tags(tag_str):
        tags = get_tag_list(tag_str)
        return " ".join([str(t).replace(" ", "_") for t in tags])

    df['processed_tags'] = df['tags'].apply(process_tags)
    df['tag_list'] = df['tags'].apply(get_tag_list)
    df['combined_features'] = df['processed_tags'] + " " + df['description']

    return df

df = load_data()

# --- 2. COMPUTE TF-IDF MATRIX ---
@st.cache_resource
def compute_tfidf(data):
    tfidf = TfidfVectorizer(stop_words='english', max_features=5000)
    matrix = tfidf.fit_transform(data['combined_features'])
    return matrix

if not df.empty:
    tfidf_matrix = compute_tfidf(df)

    all_tags = set()
    for tags in df['tag_list']:
        all_tags.update(tags)
    all_tags = sorted(list(all_tags))

    # --- HELPER FUNCTION: CINEMATIC GRID LAYOUT ---
    def display_manga_grid(dataframe, key_prefix):
        if dataframe.empty:
            st.warning("No manga found matching your criteria.")
            return

        for i in range(0, len(dataframe), 5):
            cols = st.columns(5)
            row_slice = dataframe.iloc[i:i+5]

            for col, (_, row) in zip(cols, row_slice.iterrows()):
                with col:
                    year_val = int(row['year']) if row['year'] else 'N/A'

                    # Premium HTML Poster Layout
                    html_poster = f'''
                    <div class="manga-poster">
                        <img class="manga-img" src="{row["cover"]}" referrerpolicy="no-referrer"
                        onerror="this.onerror=null;this.src='https://via.placeholder.com/300x450.png?text=Cover+Not+Found';">
                        <div class="manga-overlay">
                            <h4 class="manga-title">{row['title']}</h4>
                            <div class="manga-stats">‚≠ê {row['rating']} &nbsp;|&nbsp; üìÖ {year_val}</div>
                        </div>
                    </div>
                    '''
                    st.markdown(html_poster, unsafe_allow_html=True)

                    # Colored Tag Pills (Top 3)
                    top_tags = row['tag_list'][:3]
                    if top_tags:
                        tags_html = "".join([get_tag_html(tag) for tag in top_tags])
                        st.markdown(f"<div style='margin-bottom: 5px;'>{tags_html}</div>", unsafe_allow_html=True)

                    # Add to List Button
                    in_list = row['title'] in st.session_state.reading_list
                    btn_text = "‚úì In Library" if in_list else "‚ûï Add to Library"
                    btn_type = "secondary" if in_list else "primary"
                    st.button(
                        btn_text,
                        key=f"{key_prefix}_{row['title']}",
                        on_click=toggle_list,
                        args=(row.to_dict(),),
                        type=btn_type,
                        use_container_width=True
                    )

                    # Native Streamlit Expander for Synopsis
                    with st.expander("üìù Synopsis"):
                        st.write(row['description'])

            st.write("<br>", unsafe_allow_html=True) # Clean spacing between rows

    # --- SIDEBAR: MODERN CONTROLS ---
    with st.sidebar:
        st.markdown("<h2 style='text-align: center; color: #ff4b4b;'>‚ö° Filters</h2>", unsafe_allow_html=True)
        st.markdown("---")

        search_query = st.text_input("üîç Search Catalog", placeholder="e.g. Solo Leveling")

        st.markdown("### üè∑Ô∏è Genres")
        include_tags = st.multiselect("Must Include", all_tags)
        exclude_tags = st.multiselect("Must Exclude", all_tags)

        st.markdown("### üìä Metrics")
        min_rating = st.slider("Minimum Rating", 0.0, 5.0, 4.0, 0.1)
        years = st.slider("Release Year", 1950, 2024, (2000, 2024))

        st.markdown("### üîΩ Sort & Order")
        sort_by = st.selectbox("Sort By", ["Highest Rated", "Newest", "Oldest", "A-Z"])

    # --- UI LAYOUT TABS ---
    tab1, tab2, tab3, tab4 = st.tabs([
        "üß≠ Browse",
        "‚ú® AI Recommendations",
        "üé≤ Random Roll",
        f"üìö Library ({len(st.session_state.reading_list)})"
    ])

    # --- TAB 1: BROWSE & SEARCH (PAGINATED) ---
    with tab1:
        current_filters = (search_query, tuple(include_tags), tuple(exclude_tags), min_rating, tuple(years), sort_by)
        if st.session_state.last_filters != current_filters:
            st.session_state.current_page = 1
            st.session_state.last_filters = current_filters

        filtered = df[
            (df['rating'] >= min_rating) &
            (df['year'] >= years[0]) &
            (df['year'] <= years[1])
        ]

        if search_query:
            filtered = filtered[filtered['title'].str.contains(search_query, case=False, na=False)]
        if include_tags:
            filtered = filtered[filtered['tag_list'].apply(lambda x: all(t in x for t in include_tags))]
        if exclude_tags:
            filtered = filtered[filtered['tag_list'].apply(lambda x: not any(t in x for t in exclude_tags))]

        if sort_by == "Highest Rated":
            filtered = filtered.sort_values(by='rating', ascending=False)
        elif sort_by == "Newest":
            filtered = filtered.sort_values(by='year', ascending=False)
        elif sort_by == "Oldest":
            filtered = filtered.sort_values(by='year', ascending=True)
        elif sort_by == "A-Z":
            filtered = filtered.sort_values(by='title', ascending=True)

        ITEMS_PER_PAGE = 30
        total_results = len(filtered)
        total_pages = math.ceil(total_results / ITEMS_PER_PAGE) if total_results > 0 else 1

        if st.session_state.current_page > total_pages:
            st.session_state.current_page = total_pages

        start_idx = (st.session_state.current_page - 1) * ITEMS_PER_PAGE
        end_idx = start_idx + ITEMS_PER_PAGE
        paginated_res = filtered.iloc[start_idx:end_idx]

        if total_results > 0:
            st.markdown(f"<p style='color: #a0aec0; text-align: right;'>Showing page {st.session_state.current_page} of {total_pages} ({total_results} results)</p>", unsafe_allow_html=True)

        display_manga_grid(paginated_res, key_prefix="browse")

        # Premium Pagination Buttons
        if total_pages > 1:
            st.write("---")
            p_col1, p_col2, p_col3 = st.columns([1, 2, 1])
            with p_col1:
                if st.button("‚Üê Previous", disabled=(st.session_state.current_page == 1), use_container_width=True):
                    st.session_state.current_page -= 1
                    st.rerun()
            with p_col2:
                st.markdown(f"<div style='text-align: center; font-size: 16px; font-weight: bold; color: #ff4b4b; padding-top: 5px;'>Page {st.session_state.current_page}</div>", unsafe_allow_html=True)
            with p_col3:
                if st.button("Next ‚Üí", disabled=(st.session_state.current_page == total_pages), use_container_width=True):
                    st.session_state.current_page += 1
                    st.rerun()

    # --- TAB 2: RECOMMENDATIONS ---
    with tab2:
        col1, col2 = st.columns([3, 1])
        with col1:
            manga_titles = df['title'].dropna().unique().tolist()
            selected_manga = st.selectbox("Select a base manga for AI matching:", [""] + manga_titles)
        with col2:
            num_recs = st.slider("Results", 1, 30, 10)

        if selected_manga:
            idx = df.index[df['title'] == selected_manga].tolist()[0]
            cosine_sim = linear_kernel(tfidf_matrix[idx], tfidf_matrix).flatten()
            sim_indices = cosine_sim.argsort()[:-num_recs-2:-1][1:]
            recs = df.iloc[sim_indices]

            st.markdown(f"### Titles similar to **{selected_manga}**:")
            display_manga_grid(recs, key_prefix="rec")

            export_recs = recs[['title', 'rating', 'year', 'tags', 'description', 'cover']].copy()
            export_recs['Cover Preview'] = export_recs['cover'].apply(lambda x: f'=IMAGE("{x}")')
            csv_data_recs = export_recs.to_csv(index=False).encode('utf-8')

            st.download_button("üì• Export Recommendations to CSV", data=csv_data_recs, file_name=f"Recs_{selected_manga}.csv", mime="text/csv")

    # --- TAB 3: SURPRISE ME ---
    with tab3:
        st.markdown("<div style='text-align: center; padding: 2rem;'><h3 style='color: #ff4b4b;'>Let the algorithm decide.</h3></div>", unsafe_allow_html=True)
        if st.button("üé≤ Generate Random Top-Tier Manga", use_container_width=True):
            st.session_state.random_manga = df[df['rating'] >= 4.2].sample(10) # Filtered for higher quality randomness

        if not st.session_state.random_manga.empty:
            st.write("<br>", unsafe_allow_html=True)
            display_manga_grid(st.session_state.random_manga, key_prefix="rand")

    # --- TAB 4: READING LIST ---
    with tab4:
        if not st.session_state.reading_list:
            st.info("Your library is currently empty. Start browsing to add titles!")
        else:
            list_df = pd.DataFrame(list(st.session_state.reading_list.values()))

            export_df = list_df[['title', 'rating', 'year', 'tags', 'description', 'cover']].copy()
            export_df['Cover Preview'] = export_df['cover'].apply(lambda x: f'=IMAGE("{x}")')
            csv_data = export_df.to_csv(index=False).encode('utf-8')

            col_a, col_b, col_c = st.columns([1, 2, 1])
            with col_a:
                st.download_button("üì• Export Library", data=csv_data, file_name="MangaVault_Library.csv", mime="text/csv", use_container_width=True)
            with col_c:
                if st.button("üóëÔ∏è Clear Library", type="secondary", use_container_width=True):
                    st.session_state.reading_list = {}
                    st.rerun()

            st.write("<br>", unsafe_allow_html=True)
            display_manga_grid(list_df, key_prefix="list")

